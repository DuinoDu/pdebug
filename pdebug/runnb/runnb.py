import ast
import importlib.util
import json
import os
import shutil
import subprocess
from typing import Optional

import typer

app = typer.Typer()


class Notebook:
    def __init__(self, file_path):
        self._filepath = file_path
        self._content = None

    @property
    def content(self):
        if self._content is None:
            with open(self._filepath, "r") as fid:
                self._content = json.load(fid)
        return self._content

    @property
    def cells(self):
        return self.content.get("cells", [])

    @cells.setter
    def cells(self, cells):
        self.content["cells"] = cells

    def dump(self, savename: str) -> None:
        with open(savename, "w") as fid:
            json.dump(self.content, fid, indent=2)


def remove_skip_in_notebook(notebook):
    """Remove '# skip' cell in notebook."""
    SKIP_STRING = "# skip"

    nb = Notebook(notebook)

    new_cells = []
    for cell in nb.cells:
        if cell.get("cell_type", None) != "code":
            new_cells.append(cell)
        else:
            found_skip_flag = False
            for line in cell.get("source", []):
                if SKIP_STRING in line:
                    found_skip_flag = True
                    break
            if not found_skip_flag:
                new_cells.append(cell)
    nb.cells = new_cells
    nb.dump(notebook)


def run_func(func, cache, ctx, notebook_name):
    """Run function in notebook."""

    kwargs_str = ""
    if ctx.args:
        assert len(ctx.args) % 2 == 0
        for i in range(len(ctx.args) // 2):
            k = ctx.args[i * 2]
            assert k.startswith("--")
            k = k[2:].replace("-", "_")
            v = ctx.args[i * 2 + 1]
            if v in ["True", "False", "None"]:
                kwargs_str += f"{k}={v},"
            else:
                kwargs_str += f"{k}='{v}',"

    main_str = f"""
# Auto-generated by runnb.

from {notebook_name} import {func}
if __name__ == '__main__':
    {func}({kwargs_str})
"""
    main_python_file = os.path.join(cache, f"runnb_{func}.py")
    with open(main_python_file, "w") as fid:
        fid.write(main_str)
    subprocess.run(["python3", f"{main_python_file}"])


def run_all(func, cache, ctx, notebook_name):
    """Run all in notebook."""

    main_str = f"""
# Auto-generated by runnb.

from {notebook_name} import *
"""
    main_python_file = os.path.join(cache, "runnb_all.py")
    with open(main_python_file, "w") as fid:
        fid.write(main_str)
    subprocess.run(["python3", f"{main_python_file}"] + ctx.args)


def run_test(notebook, cache, ctx, notebook_name):
    """Run test in notebook."""
    test_code_list = []
    try:
        import astunparse
    except ImportError as e:
        print("pip install astunparse to run test in notebook.")
        return

    nb = Notebook(notebook)
    for cell in nb.cells:
        if cell.get("cell_type", None) != "code":
            continue
        source = "".join(cell.get("source", []))
        if not source:
            continue
        contains_test = "def test_" in source
        if not contains_test:
            continue

        f_ast = ast.parse(source)
        nb_body = []
        test_body = []
        for obj in f_ast.body:
            if isinstance(obj, ast.FunctionDef) and "test_" in obj.name:
                test_body.append(obj)
            else:
                nb_body.append(obj)
        f_ast.body = test_body
        test_code_list.append(astunparse.unparse(f_ast))

        f_ast.body = nb_body
        new_source = astunparse.unparse(f_ast).split("\n")
        cell["source"] = new_source

    nb.dump(notebook)

    test_str = f"""
# Auto-generated by runnb.

from {notebook_name} import *
"""
    for code in test_code_list:
        test_str += code

    test_python_file = os.path.join(cache, "runnb_test.py")
    with open(test_python_file, "w") as fid:
        fid.write(test_str)

    subprocess.run(["pytest", f"{test_python_file}"] + ctx.args)


def run_install(notebook, ctx):
    """Install all notebook deps."""
    import_lines = []

    if notebook.endswith(".py"):
        import_lines.extend(
            [
                line.strip()
                for line in open(notebook).readlines()
                if "import " in line and not line.strip().startswith("#")
            ]
        )
    else:
        nb = Notebook(notebook)
        for cell in nb.cells:
            if cell.get("cell_type", None) != "code":
                continue
            import_lines.extend(
                [
                    line.strip()
                    for line in cell.get("source", [])
                    if "import " in line and not line.strip().startswith("#")
                ]
            )
    lib_names = []
    for line in import_lines:
        if not line:
            continue
        if line.startswith("import ") or line.startswith("from "):
            lib_name = line.split(" ")[1].split(".")[0]
            lib_names.append(lib_name)
        else:
            raise RuntimeError
    lib_names = set(lib_names)

    # find white_list
    white_list = [
        line.strip().split(":")[1].strip()
        for line in open(notebook).readlines()
        if "runnb_install_skip" in line
    ]

    for name in lib_names:
        if name in white_list:
            continue
        spec = importlib.util.find_spec(name)
        if spec is None:
            cmd = f"pip3 install {name} {' '.join(ctx.args)}".strip()
            print(cmd)
            subprocess.run(cmd.split(" "))


def run_submit(notebook, cache, ctx, notebook_name):
    """Install all notebook deps."""
    test_str = f"""
# Auto-generated by runnb.

from runnb.submit import main
from {notebook_name} import runnb_submit_config_file, runnb_submit_config
from omegaconf import OmegaConf

config = OmegaConf.load(runnb_submit_config_file)
config.update(runnb_submit_config)
main(config)
"""
    python_file = os.path.join(cache, "runnb_submit.py")
    with open(python_file, "w") as fid:
        fid.write(test_str)
    subprocess.run(["python3", f"{python_file}"])


@app.command(
    context_settings={"allow_extra_args": True, "ignore_unknown_options": True}
)
def runnb(
    notebook: str,
    action: str = typer.Argument(
        ...,
        help="available: runtest, install, notebook, func_name_in_notebook,",
    ),
    ctx: typer.Context = typer.Argument(..., help="extra args to action"),
    cache: Optional[str] = typer.Option(".runnb", help="cache folder"),
):
    """Run action using notebook."""
    typer.echo(
        typer.style(f"Run {action} in {notebook}", fg=typer.colors.GREEN)
    )
    notebook = os.path.abspath(notebook)

    notebook_name = os.path.splitext(os.path.basename(notebook))[0]
    notebook_name = notebook_name.replace("-", "_")

    os.makedirs(cache, exist_ok=True)

    # copy notebook or python file
    notebook_copied = os.path.join(cache, os.path.basename(notebook))
    shutil.copy(notebook, notebook_copied)

    # generate python file
    if notebook.endswith(".ipynb"):
        remove_skip_in_notebook(notebook_copied)
        lib_python_file = os.path.join(cache, f"{notebook_name}.py")
        cmd = f"jupytext {notebook_copied} --to py --output {lib_python_file}"
        subprocess.run(cmd.split(" "))
        assert action not in ["submit"], "NotImplemetedError"
    elif notebook.endswith(".py"):
        assert action not in ["runtest", "all"], "NotImplemetedError"

    if action == "runtest":
        # run test in notebook
        run_test(notebook_copied, cache, ctx, notebook_name)
    elif action == "install":
        # install all notebook deps
        run_install(notebook_copied, ctx)
    elif action == "submit":
        # submit to cluster
        run_submit(notebook_copied, cache, ctx, notebook_name)
    elif action == "all":
        # run all in notebook
        run_all(action, cache, ctx, notebook_name)
    else:
        # run function in notebook
        run_func(action, cache, ctx, notebook_name)


def main():
    app()


if __name__ == "__main__":
    main()
